use clap::crate_version;
use devenv::{
    cli::{Cli, Commands, ContainerCommand, InputsCommand, ProcessesCommand, TasksCommand},
    config, log, utils, Devenv,
};
use miette::Result;
use std::fs::File;
use std::io::BufWriter;
use tracing::level_filters::LevelFilter;
use tracing::{debug, info, warn};

#[tokio::main]
async fn main() -> Result<()> {
    let cli = Cli::parse_and_resolve_options();

    let print_version = || {
        println!(
            "devenv {} ({})",
            crate_version!(),
            cli.global_options.system
        );
        Ok(())
    };

    let command = match cli.command {
        None | Some(Commands::Version) => return print_version(),
        Some(Commands::Direnvrc) => {
            print!("{}", devenv::DIRENVRC.to_string());
            return Ok(());
        }
        Some(cmd) => cmd,
    };

    let level = if cli.global_options.verbose {
        log::Level::Debug
    } else if cli.global_options.quiet {
        log::Level::Silent
    } else {
        log::Level::default()
    };

    log::init_tracing(level, cli.global_options.log_format);

    let file =
        std::fs::File::create("/tmp/devenv-lsp.log").expect("Couldn't create devenv-lsp.log file");

    let file = BufWriter::new(file);
    let (non_blocking, _guard) = tracing_appender::non_blocking(file);
    let subscriber = tracing_subscriber::fmt()
        .with_max_level(LevelFilter::DEBUG)
        .with_ansi(false)
        .with_writer(non_blocking)
        .finish();
    let _ = tracing::subscriber::set_global_default(subscriber);
    let file = File::open("/home/k3ys/tmp/option.json").unwrap();
    let json: serde_json::Value =
        serde_json::from_reader(file).expect("file should be proper JSON");
    // debug!("trimmed_json {:?}", trimmed_json);
    let mut flatten_json = utils::flatten(json);
    // debug!("flatten_json: {}", serde_json::to_string_pretty(&flatten_json).unwrap());
    let filter_keys = vec![
        String::from("declarations"),
        String::from("loc"),
        String::from("readOnly"),
    ];
    let filter_keys_refs: Vec<&str> = filter_keys.iter().map(|s| s.as_str()).collect();
    let completion_json = utils::filter_json(&mut flatten_json, filter_keys_refs);

    let mut config = config::Config::load()?;
    for input in cli.global_options.override_input.chunks_exact(2) {
        config.add_input(&input[0].clone(), &input[1].clone(), &[]);
    }

    let mut options = devenv::DevenvOptions {
        global_options: Some(cli.global_options),
        config,
        ..Default::default()
    };

    // we let Drop delete the dir after all commands have ran
    let _tmpdir = if let Commands::Test {
        dont_override_dotfile,
    } = command
    {
        let pwd = std::env::current_dir().expect("Failed to get current directory");
        let tmpdir =
            tempdir::TempDir::new_in(pwd, ".devenv").expect("Failed to create temporary directory");
        if !dont_override_dotfile {
            info!(
                "Overriding .devenv to {}",
                tmpdir.path().file_name().unwrap().to_str().unwrap()
            );
            options.devenv_dotfile = Some(tmpdir.path().to_path_buf());
        }
        Some(tmpdir)
    } else {
        None
    };

    let mut devenv = Devenv::new(options).await;

    match command {
        Commands::Shell { cmd, args } => devenv.shell(&cmd, &args, true).await,
        Commands::Test { .. } => devenv.test().await,
        Commands::Container {
            registry,
            copy,
            docker_run,
            copy_args,
            name,
            command,
        } => {
            devenv.container_name = name.clone();
            match name {
                None => {
                    if let Some(c) = command {
                        match c {
                            ContainerCommand::Build { name } => {
                                devenv.container_name = Some(name.clone());
                                let _ = devenv.container_build(&name).await?;
                            }
                            ContainerCommand::Copy { name } => {
                                devenv.container_name = Some(name.clone());
                                devenv
                                    .container_copy(&name, &copy_args, registry.as_deref())
                                    .await?;
                            }
                            ContainerCommand::Run { name } => {
                                devenv.container_name = Some(name.clone());
                                devenv
                                    .container_run(&name, &copy_args, registry.as_deref())
                                    .await?;
                            }
                        }
                    }
                }
                Some(name) => {
                    match (copy, docker_run) {
                        (true, false) => {
                            warn!("--copy flag is deprecated, use `devenv container copy` instead",);
                            devenv
                                .container_copy(&name, &copy_args, registry.as_deref())
                                .await?;
                        }
                        (_, true) => {
                            warn!(
                                "--docker-run flag is deprecated, use `devenv container run` instead",
                            );
                            devenv
                                .container_run(&name, &copy_args, registry.as_deref())
                                .await?;
                        }
                        _ => {
                            warn!("Calling without a subcommand is deprecated, use `devenv container build` instead");
                            let _ = devenv.container_build(&name).await?;
                        }
                    };
                }
            };
            Ok(())
        }
        Commands::Init { target } => devenv.init(&target),
        Commands::Search { name } => devenv.search(&name).await,
        Commands::Gc {} => devenv.gc(),
        Commands::Info {} => devenv.info().await,
        Commands::Repl {} => devenv.repl(),
        Commands::Lsp {} => devenv.lsp(&completion_json).await,
        Commands::Build { attributes } => devenv.build(&attributes).await,
        Commands::Update { name } => devenv.update(&name).await,
        Commands::Up { process, detach } => devenv.up(process.as_deref(), &detach, &detach).await,
        Commands::Processes { command } => match command {
            ProcessesCommand::Up { process, detach } => {
                devenv.up(process.as_deref(), &detach, &detach).await
            }
            ProcessesCommand::Down {} => devenv.down(),
        },
        Commands::Tasks { command } => match command {
            TasksCommand::Run { tasks } => devenv.tasks_run(tasks).await,
        },
        Commands::Inputs { command } => match command {
            InputsCommand::Add { name, url, follows } => devenv.inputs_add(&name, &url, &follows),
        },

        // hidden
        Commands::Assemble => devenv.assemble(false),
        Commands::PrintDevEnv { json } => devenv.print_dev_env(json).await,
        Commands::GenerateJSONSchema => {
            config::write_json_schema();
            Ok(())
        }
        Commands::Direnvrc => unreachable!(),
        Commands::Version => unreachable!(),
    }
}
